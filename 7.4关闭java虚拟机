java虚拟机可能以有序的方式关闭，也可能突然的关闭。当最后一个普通的（非守护线程）线程终止时发起有序的关闭，可能通过调用System.exit，或者通过其他一些特定
于平台的方式（诸如发送一个SIGINT或者敲击Ctrl-C）。尽管这是关闭java虚拟机的标准同时也是推荐的方式，java虚拟机仍然可能由于调用Runtime.halt或者通过操作系
统杀死jvm进程的方式而突然关闭（例如发送一个SIGKILL指令）。

7.4.1关闭虚拟机的钩子方法
有序关闭时，java虚拟机会启动所有已经注册的关闭钩子。关闭钩子是那些通过Runtime.addShutdownHook注册的未启动的线程。java虚拟机无法保证关闭钩子的启动顺序，

7.4.2守护线程
有时候你想要创建一个线程来执行一些帮助功能但是你不想这个线程的存在阻止到java虚拟机的关闭。这就是守护线程的所要做的。
线程分为两种类型：普通线程和守护线程。当java虚拟机启动时，它创建的所有线程，除了主线程，都是守护线程（诸如垃圾回收线程，其他的管理线程）。当一个线程被创
建时，它默认继承创建它的线程的守护状态，所以默认情况下，主线程创建的任何线程也都是普通线程。
普通线程和守护线程的唯一不同就是他们推出时会发生什么。当一个线程退出时，java虚拟机会执行一个正在运行的线程的清单动作，如果剩下的所有线程都是守护线程，它
会发起一个有序的关闭。当java虚拟机终止，任何剩下的守护线程都被废弃——finally块不会执行，栈不会解除——java虚拟机仅仅退出。
守护线程应该少量使用——能随时放弃而不需要清理的正在处理中的活动很少。特别是使用守护线程来执行那些可能会执行I/O操作的任务是非常危险的。守护线程最好仅用于
一些‘家务管理’任务，诸如一个周期性地从缓存中移除过期的条目的后台线程。
守护线程不适宜管理应用中的一些服务的生命周期。
7.4.3终结者
垃圾收集线程能够很好地回收那些不再需要的内存资源，但是一些资源，诸如文件或者套接字句柄，当不再需要时，必须显式地归还给操作系统。为了能够帮助回收这些资源，
垃圾收集线程对那些拥有非平凡的finalize方法的对象特殊对待：当它们被垃圾回收线程回收后，finalize方法将被调用来释放那些持久化资源。
既然finalizer可以运行在一个由java虚拟机管理的线程中，任务能够被一个finalizer访问的状态将会被不止一个线程访问，因此它们必须通过同步机制来访问。Finalize
rs不能保证它们什么时候运行，甚至无法保证它们是否会运行，并且它们致使那些带有非平台的finalize方法的对象有很大的性能开销。正确地编写它们也极其困难。大多数
情况下，finally块和显式地close方法的结合能够比finalizer更好的管理资源；唯一的例外是当你需要管理那些持有通过本地方法获取到的资源的对象。基于这些原因及别
的因素，尽量避免写或者使用带有finializers的类（除了平台类库中的类）。
  # 避免Finalizers.

