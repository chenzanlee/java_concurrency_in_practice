7.3线程异常终止的处理
一个单线程的控制台应用程序由于一个不可捕获的异常而终止时很明显的————程序停止运行，输出与正常的程序输出不同的堆栈。在并发应用程序中一个线程的失败并不总是
显而易见的。堆栈可能会被打印到控制台，但是可能没人一直盯着控制台。此外，当一个线程失败时，应用可能看起来继续在工作，因而该线程的失败可能没人注意到。幸运
的是，我们有方法检测和阻止线程从一个应用中泄露。
线程过早死亡的主要原因是运行时异常。因为这些异常表明一个程序错误或者其它不可修复的错误，它们一般不被捕获。相反，它们沿着调用栈一路向上传播，缺省的行为通
常是打印异常堆栈到控制台，终止线程的执行。
线程异常死亡的后果可能是良性的，也可能是灾难性的，取决于线程在应用中扮演的角色。一个线程池失去一个线程可能会影响性能，但是一个在50个线程的线程池下运行良
好的应用很大可能也能在49线程的线程池的情况下运行的不错。但是一个图形用户界面的应用如果失去了事件分发线程将非常引人注目————该应用将会停止处理事件，图形用
户界面将会冻住。124页的OfTime向我们展示了线程泄露的严重后果：由Timer表示的服务将永远不会执行。
由于任何代码都有可能会抛出一个运行时异常。无论何时你调用其它的方法，你其实都是在相信它将会正常返回，或者抛出一个它的方法签名中声明的受检异常。你越是不熟
悉正在被调用的代码，你越应该对它的行为保持怀疑。
像线程池中的工作线程或是在Swing框架中的事件分发线程这样的任务处理线程，它们的整个生命周期一直在调用未知代码，通过像Runnable这样的抽象封装接口，这些线程
应该对它们调用的代码良好运行持怀疑态度。如果一个服务，如Swing事件线程，仅仅因为写得糟糕的事件处理器抛出一个运行时异常而挂掉就不太好。因此，这些服务设施
应该在一个捕获非受检异常的try-catch块中调用任务，或者在一个try-finally块中，确保当线程异常退出时，框架能够被告知到，从而能够采取一些正确的行动。这是仅
有的几次你可能想要考虑捕获运行时异常的时机之一——当你调用通过像Runnable这样接口抽象的未知的，无法信任的代码时。
Listing7.23举例说明了一种构建线程池中的工作线程的方式。如果一个任务抛出了一个不受检的异常，它允许线程死亡，但是在此之前必须向外部运行框架发出线程已经死
亡的通知。该运行框架可能随后用一个新的线程来替换该工作线程，或者选择不去替换，因为该线程池正在关闭，或者该线程池中已有足够的线程来满足当前的需求。线程池
执行器和Swing使用这一技术来确保一个表现糟糕的任务不会阻止后面的任务的执行。如果你正在写一个工作者线程类来执行提交过来的任务，或者调用一些无法信任的外部
代码，诸如动态加载的插件，使用这些方法中的一种来避免一个写得糟糕的任务或者插件导致碰巧调用该任务或插件的线程挂掉。
Listing 7.2.3 典型的线程池工作线程的结构
public void run(){
  Throwable thrown=null;
  try{
    while(!isInterrupted){
      runTask(getTaskFromWorkQueue());
    }catch(Throwable e){
      thrown=e;
    }finally{
      threadExited(this,thrown);
    }
  
  }

}

7.3.1不可捕获的异常的处理器
前面的部分提供了一种主动的应对不受检异常问题的途径。线程类API也提供了UncaughtExceptionHandler机制，该机制能够让你检测到由于一个不受检异常导致的线程
死亡。这两种方式是互补的：一起使用，提供对线程泄露的更深层防御。当一个线程由于一个未捕获的异常而退出时，java虚拟机将这一事件报告给一个应用程序范围内
的UncaughtExceptionHandler（见 7.24）;如果该handler不存在，缺省的行为是将调用栈打印到系统标准错误流。
Listing 7.24 UncaughtExceptionHandler Interface
public interface UncaughtExceptionHandler{

}

该handler应该对一个未捕获的异常做些什么取决于你的服务的质量要求。最通用的反应是写一个错误信息及异常调用堆栈到应用程序的日志中，像Listing 7.25所示那
样。Handlers也可以采取更直接的动作，诸如试着去重启线程，关闭该应用，paging an operator,或者其它的正确或者诊断性的动作。
Listing 7.25 记录异常的UncaughtExceptionHandler

public class UEHLogger implements Thread.UncaughtExceptionHandler{
  public void uncaughtException(Thread t,Throwable e){
    Logger logger=Logger.getAnonymousLogger();
    logger.log(Level.SEVERE,"Thread terminated with exception :"+t,getName(),e);
  }
}

在一个长时间运行的应用中，总是为所有的线程使用至少记录下该异常的不可捕获的异常处理者。

通过提供一个ThreadFactory给线程池构造器，为线程池中的线程设置一个UncaughtExceptionHandler。（和所有的线程操作一样，只用线程的拥有者应该改变它的Unc
aughtExceptionHandler。)标准的线程池允许一个未捕获的任务异常来终结线程池中的线程，但是使用一个try-finally块来当这一事件发生时通知线程池，以便该线程
能够被替代。没用未捕获异常处理器或者其他的失败通知机制，任务可能看起来悄无声息的失败，这将令人感到困惑。如果你想要当一个任务由于异常而导致失败时收到通
知，以便你能够采取一些特定于任务的恢复行动，你可以采用使用捕获异常的Runnable或者Callable接口包装任务或者覆写ThreadPoolExecutor类提供的afterExecut
e()钩子方法。
有点令人困惑的是，任务抛出的异常交由UncaughtExceptionHandler处理，只对那些通过execute方法提交的任务有效。对那些通过submit方法提交的任务,任何抛出的
异常，无论是受检的异常还是不受检的异常，将被视作任务的返回状态的一部分。如果一个通过submit方法提交的任务由于一个异常终结，该异常将被包裹进一个Executi
onException，通过future的get方法重新抛出。

