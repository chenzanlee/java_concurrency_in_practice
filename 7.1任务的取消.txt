7.1任务的取消
	如果外部代码可以将某个活动在其正常完成状态前移到完成状态，那么该活动是可以取消的。有许多原因使得你可能想取消一个活动：
	   用户请求取消。如在使用图形用户界面应用时，用户通过点击取消按钮或者通过一个类似于jmx的管理接口请求取消；
	   限制时间的活动。一个应用程序在给定的有限时间内寻找问题解空间，然后选择在该这段时间内所找到的最好的解决方案。当定时器设定的时间消逝，		   任何仍在搜索解决方案的任务将取消；
	   应用事件。一个应用通过将拆分问题为一系列不同的子任务来寻找问题空间的不同区域。当一个子任务寻找到解决方案，所有其它仍然在寻找方案的任务将		   被取消；
           错误。一个web爬虫寻找相关的网页，将网页或概要数据保存到硬盘上。当一个爬虫任务遇到一个错误（例如，磁盘已满），其它的正在爬数据的任务将被取	    消，可能会记录它们当前的状态以便稍后重新开始；
	   关闭。当一个应用或者服务被关闭，对于那些正在被处理的工作及那些等待处理的工作，应当做些什么。优雅的关闭时，那些当前正在执行的任务应该允许		   他们完成；立即关闭的情况，当前正在执行的任务可能被取消。
	
	在java中，没有安全的办法来抢占式地停止一个线程，因此也没有安全的办法来抢占式地停止一个任务。在java中，只有协作机制，通过这种方式，任务和请求     任务取消的代码遵循一个一致的协议。
	
	这种协作机制的一种形式是设置一个任务或周期性的检查的请求取消的标志；如果任务发现该标志设置了，该任务便早点终结。Listing7.1中的		     PrimeGenerator,它在被取消前一直列举质数，说明了这一技巧。cancel方法设置cancelled标志，主循环在搜索下一个质数前检查这一标志。（为了这一技术能够     可靠的工作，cancelled必须设置为volatile修饰的字段，保证该标志位修改的可见性）
	
	Listing7.2展示了该类的一个示例用法，让质数生成器PrimeGenerator运行一秒后取消它。该生成器未必在确切的一秒钟后停止，由于在任务被请求取消与主     循环检查该任务是否被取消之间可能有一些延迟。cancel方法在一个finally语句块中被调用，从而
	确保即使对sleep方法的调用被中断了，质数生成器仍然会被取消。如果cancel方法不被调用，该寻找质数的线程将一直运行下去，消耗cpu时间片，阻止java     虚拟机进程的退出。
	
	一个想要能够被取消的任务必须有一个指明了请求取消的方式，取消的时机，取消时做些什么的取消政策——其它代码可以怎样请求取消该任务，该任务什么时候     检查取消被请求了，该任务该做些什么来响应一个取消请求。
	考虑一个停止支付现金的真实例子。银行有关于如何提交一个停止支付请求，在处理这种请求时需要保证的怎样的响应性，当一次支付被真正取消时该遵循怎样     的步骤（诸如通知其它涉及到这次交易的银行以及根据支付者的账户评估一个费用），这些步骤及
	保证组成了支付的取消原则。
	
	Listting7.1 使用一个volatile字段来持有取消状态
	
	@ThreadSafe
	public class PrimeGenerator implements Runnable{
		@GuardedBy(“this”) 
		private final List<BigInteger> primes=new ArrayList<BigInteger>();
		private volatile cancelled;
		public void run(){
			BigInteger p=BigInteger.ONE;
			while(!cancelled){
				p=p.nextProbablePrime();
				synchronized(this){
					primes.add(p);
				}
			}
		}
		public void cancel(){
			cancelled=true;
		}
		public synchronized List<BigInteger> get(){
			return new ArrayList<BigInteger>(primes);
		}
	}

	Listing7.2 一秒钟内生成的质数
	
	List<BigInteger> aSecondOfPrimes() throws InterruptedException{
		PrimeGenerator generator=new PrimeGenerator();
		new Tnread(generator).start();
		try{
			SECONDS.sleep(1);
		}finally{
			generator.cancel();
		}
		return generator.get();
	}

	PrimeGenerator使用一个简单的取消政策：客户端代码通过调用cancell方法来请求取消，PrimeGenerator每当一个质数找到就检测是否取消，当它检测到取     消请求时就退出。

7.1.1中断
	质数生成器中的取消机制最终将导致寻找质数的任务退出，虽然这可能会要一小会时间。然而，如果一个使用这种方式的任务调用了一个像BlockingQueue的       put方法这样的阻塞方法，我们可能有一个更严重的问题——任务可能永远不会检查取消标志，因此可能永远不会终止。
	
	Listing1.3中的BrokenPrimeProducer说明了这个问题。生产者线程产生质数并将它们存放在一个阻塞队列中。如果该生产者产生质数的速度大于消费者从队     列中取出质数的速度，该队列最终会填满，put方法将被阻塞住。如果消费者试图取消生产者任务而此时生产者正阻塞在put方法时，会发生什么？它可以调用cancel     方法来将canclled标志设置为true——但是生产者将永远不会检查这一标志，因为它将永远不会从被阻塞的put方法中解脱出来（因为消费者已经停止从队列中取出质     数）。
	
	我们在第五章曾提示过，某些阻塞库方法支持中断。线程中断是一种协作机制，一个线程用线程中断来向另一个线程发出信号，告知该线程它应该在它方便时，     或者如果它愿意的话，停止它现在手头正在做的，做些其它别的事。
	虽然java API和java语言规范中没有将中断与任何特定的取消绑在一起，然而，实际上，使用中断来做取消之外的任何事都是脆弱的，并且在大的应用中很难维     持。
	每个线程都有一个boolean类型的interrupted状态字段；中断一个线程会把该字段设置为true.正如Listing7.4所示,线程类包含有中断线程和查询线程中断     状态的方法。interrupt方法中断目标线程的状态，isInterrupted方法返回目标字段的中断状态。拙劣的命名为interrupted的静态方法清空当前线程的中断状       态，返回它前一次的值，这是清空中断状态的唯一方式。
	
	像Thread.sleep和Object.wait这样的阻塞式库方法试图去检测一个线程什么时候被请求中断，然后早早地返回。它们通过清除中断状态字段值，抛出一个被     中断异常表明阻塞式操作由于中断而过早完成这种方式来响应中断。Java虚拟机没有对一个阻塞式方法多快检测中断作出保证，但实际上，对中断的检测通常相当       快。
	
	Listing7.3 不可靠的取消，导致Producers卡在了阻塞式操作中。不要这么做。
	
	class BrokenPrimeProducer extends Thread{
		private final BlockingQueue<BigInteger> queue;
		private volatile Boolean cancelled=false;
		BrokenPrimeProducer(BlockingQueue<BigInteger> queue){
			this.queue=queue;
		}
		public void run(){
			try{
				BigInteger p=BigInteger.ONE;
				while(!cancelled){
					queue.put(p=p.nextProbablePrime());
				}
			}catch(InterruptedException cousumed){
			}		
		}
		public void cancel(){
			cancelled=true;
		}
	}

	void consumePrimes() throws InterruptedException{
		BlockingQueue<BigInteger> primes=…;
		BrokenPrimeProducer producer=new BrokenPrimeProducer(primes);
		producer.start();
		try{
			while(needMorePrimes()){
				consume(primes.take());
			}finally{
			producer.cancel();
		}
	}

	Listing7.4 Thread类中中断相关的方法
	
	public class Thread{
	public void interrupt(){…}
	public boolean isInterrupted(){…}
	public static Boolean interrupted(){…}
	}
	
	如果一个线程在未阻塞时被中断，它的阻塞状态字段会被设置，交由被取消的活动来决定检查中断字段来检测中断。采用这种方式，中断是粘性的——如果它没有     触发一个被中断异常，中断的证据将一直保留直到某人谨慎地清除掉中断状态。
	
	调用interrupt方法未必让目标线程停止正在做的事情；它仅仅是传递一个信息：中断被请求了。
	
	关于中断的一个更好的看法是它不是真正地中断一个正在运行的线程，它只是请求线程在下一个合适的时机中断自身（这些时机叫做取消点）。一些方法，诸如     wait,sleep,join，需要认真考虑中断请求，当它们接收到一个中断请求或在方法入口遇到一个已经
	
	设置的中断状态字段时抛出一个异常。表现好的方法可能完全忽略中断请求只要他们将中断请求保留以便调用代码能够对该中断请求做些什么。槽糕的方法吞下     中断请求，因此使得调用栈更高层的代码没有机会对该中断请求做些什么。
	
	静态的interrupted方法需要谨慎使用，因为它清空了当前线程的中断状态字段的值。如果你调用interrupted方法，并返回true,除非你打算吞下该中断请       求，否则你应该对此做些什么——或者抛出被中断异常，或者像94页Listing5.10那样，再次调用interrupt
	方法来恢复被中断状态字段的值。
	
	BrokenPrimeProducer展示了定制的取消机制是如何并不总是与阻塞式的库方法打交道。如果你编码你的任务来对中断请求作出响应，利用众多的库方法提供的     中断支持。
	
	中断通常是实现取消的最合理的方式。
	
	BrokenPrimeProducer可以很容易地通过使用中断取代使用一个boolean类型的标志字段来请求取消的方式修复，同时也简化了代码，如下Listing7.5所示。

	Listing7.5使用中断来取消
	
	class PrimeProducer extends Thread{
		private final BlockingQueue<BigInteger> queue;
		PrimeProducer(BlockingQueue<BigInteger> queue){
			this.queue=queue;
		}
		public void run(){
			try{
				BigInteger p=BigInteger.ONE;
				while(!Thread.currentThread().isInterrupted()){
					queue.put(p=p.nextProbablePrime());
				}
			}catch(InterruptedException consumed)[
				/*Allow thread to exit*/
			}
		}
		public void cancel(){
			interrupt();
		}
	}

7.1.2线程中断政策

	线程应该有一个中断执行的政策，如同任务应该有一个取消政策一样。一个中断政策决定了一个线程如何解释（看待）一个中断请求——当检测到一个中断请求       时，它做些什么（如果需要的话），相对于一次中断，它的哪些工作应该看作是原子的（或者说，它
	的哪些工作是不可以被中断的，需要被当做一个整体），它对中断的响应速度如何。
	
	最合理的中断政策是某种形式上的线程级别或者服务级别的取消：
	
	尽可能快的退出（满足实际的实践需求），做一些必要的清理，可能通知一些拥有该线程的实体该线程正在退出。虽然可以建立一些别的中断政策，诸如暂停或     继续一个服务，但是使用非标准的中断政策的线程或线程池可能局限于传递那些清楚这些线程或线
	程池所使用的中断政策而编写的任务以供执行。	
	
	区分任务和线程各自应该如何对中断做出反应是非常重要的。一个中断请求可能有不止一个的期望接受者——中断一个线程池中的工作线程可能意味着既要取消该     工作线程当前正在执行的任务，同时还要关闭改工作线程。
	
	任务不是在他们拥有的线程中执行，它们向一个诸如线程池这样的服务租借线程来执行任务。 不拥有该线程的代码（例如，就线程池而言，任何线程池实现之外     的代码）要注意保留线程的中断状态，从而拥有该线程的代码最终能够对此作出响应，即使客户
	
	代码也对此中断作出了一些响应动作。（如果你为某人照看房子，你不能将在他们离开后收到的邮件扔掉——你将它们保管好，让他们回来后处理这些邮件，即使     你确实看了他们的杂志。）
	
	这也解释了为什么大多数类库阻塞方法仅仅简单地抛出被中断异常作为对中断的响应。因为它们将不会执行在一个它们拥有的线程中，所以它们实现了对于任务     或类库代码来说最合理的取消政策：尽快退出，将中断消息传递给调用者以便调用栈更高层的代码
	能够采取进一步的动作。
	
	当任务觉察到一个中断请求时，它不必立即放弃一切——它可以选择记住它被中断了来推迟到一个更适宜的时机结束它正在执行的任务，然后抛出一个被中断异常     或者其他的指示中断的方式。这一技巧可以避免当一个正在更新中的活动被中断时，数据结构被损
	坏。
	
	任务不应假设它的执行线程的中断政策，除非它被显式的设计运行在一个拥有特定的中断政策的服务中。不管任务将中断视为取消还是采取一些其他的行动，它     都应该注意将正在执行的线程的中断状态保留。如果它不是简单地将被中断异常传播给它的调用者，
	他应该在捕获被中断异常后恢复中断状态：
	    Thread.currentThread.interrupt();
	
	正如任务代码不应假设中断对于它的执行线程意味着什么，取消相关的代码不应该对任意线程的中断政策作出假设。一个线程只有它的所有者能够作出推断；所     有者可以以一种恰当的取消机制来封装线程的中断政策方面的知识，例如提供一个shutdown方法。
	
	因为每个线程有各自的中断政策，你不应该中断一个线程除非你知道中断对于那个线程意味着什么。
	
	批判家们嘲笑java的中断机制，因为它不能提供一个抢占式的中断能力，而是强迫开发者来处理被中断异常。然而，推迟中断请求的能力使得开发者们能够设计     灵活的，对于应用来说在响应和健壮性方面适宜的中断政策。
	
7.1.3 对中断的响应

	在5.4部分提到，当你调用一个诸如Thread.sleep或BlockingQueue.put方法这样可以被中断的阻塞方法时，有两种可行的处理被中断异常的策略：
	
	传播该异常（可能在完成特定于该任务的清理之后），使你的方法也成为一个可被中断的阻塞方法；
	
	恢复中断状态以便调用栈更高层的代码能够处理该中断请求;
	
	传播被中断异常可以简单地添加被中断异常到throws子句。像下面的Listing7.6的getNextTask方法显示的那样：
	Listing 7.6 传播被中断异常给调用者
	BlockingQueue<Task> queue;
	…
	public Task getNextTask() throws InterruptedException{
		return queue.take();
	}
	
	如果你不想或者不能传播被中断异常（也许是由于你的任务通过Runnable接口来定义的），你需要找到另一种方法来保存该中断请求。标准的做法是通过再次调     用interrupt来恢复该中断状态。你不应该捕获 InterrruptedException，然后在捕获块（catch）中什么也不做，咽下该InterruptedException，除非你的代码     确实是在实现一个线程的中断政策。PrimeProducer吞下了该中断，但是这样做是因为知道线程将要终结，因此调用栈上没有更高层代码需要知道该中断了。大多数     代码不知道它将运行于那个线程，因此应该保存该中断状态。

	只有实现线程的中断政策的代码可以吞下一个中断请求。通用的任务或者库代码绝不能吞下中断请求。

	不支持取消但仍然调用可以被中断的阻塞方法的那些活动将不得不在一个循环中调用这些可以被中断的阻塞方法，当中断被检测到时重新执行循环体中的代码。     在这种情况下，它们应该通过局部变量保存中断状态，然后在方法返回之前恢复该中断状态，像
	Listing7.7所展示的那样，而不是一捕获被中断异常就设置线程被中断。过早地设置线程被中断的状态字段可能导致一个无限死循环，因为大多数可以被中断的     阻塞方法在进入该方法时检查被中断状态字段，如果该字段被设置为true的话立即抛出线程被中断异常InterruptedException.(可被中断的方法通常为了尽可能快     地对中断作出响应，在阻塞或者做任何重要的工作前审查中断状态)

	Listing7.7 在退出之前恢复中断的不可取消的任务
	public Task getNextTask(BlockingQueue<Task> queue){
		boolean interrupted=false;
		try{
			while(true){
				try{
					return queue.take();
				}catch(InterruptedException e){
					interrupted=true;
					//失败并重新尝试
				}
			}
		}finally{
			if(interrupted){
				Thread.currentThread().interrupt();
			}
		}
	}

	如果你的代码不能调用可被中断的阻塞方法，它仍然可以通过在任务代码中审查当前线程的中断状态字段来对中断作出响应。需要在效率和响应性之间做取舍来     设置审查频率。如果你有高响应性方面的要求，你不能调用那些潜在的可能需要运行很长时间而它们自身不能对中断作出响应的方法，潜在地限制了你对一些库方法     的调用。
	
	取消可能牵涉到除了中断状态之外的情形；中断可以用来获得被中断线程的注意，那些被正在调用中断方法的线程保存在其他地方的信息可以用来为被中断的线     程提供更进一步的指示。（访问这些信息时，请确保使用了同步机制synchronization）。例如，
	当一个ThreadPoolExecutor拥有的工作线程检测到中断请求，它会查看线程池是否正在被关闭。如果是的话，它会在结束前执行一些线程池的清理工作；否则     它会创建一个新的线程来维持线程池的期望大小。
7.1.4例子：TimedRun
	很多问题的解决可能需要花费无限长的时间（例如：枚举所有的质数）；对于其他的问题，答案可能很快被找到也可能耗费很久。在这些场景中，能够说“花费至     多十分钟来寻找答案”或“在十分钟内列举出你知道的所有答案”可能很有用。Listing7.2中的aSecondOfPrimes方法开启了一个PrimeGenerator(质数生成器)线       程，然后在一秒钟之后中断了它。尽管该PrimeGenerator可能会花费不止一秒钟来停止，它最终会察觉该中断请求并停止，以允许线程终结。但是执行一项任务的另     一方面是你想要查明该任务是否会抛出一个异常。如果PrimeGenerator在设置的超时时间消逝前抛出一个未受检的异常，它可能不被察觉，因为该质数生成器在一个     分开的未显示地处理异常的线程中执行。
	
	Listing7.2 一秒钟内生成的质数
	List<BigInteger> aSecondOfPrimes() throws InterruptedException{
		PrimeGenerator generator=new PrimeGenerator();
		new Tnread(generator).start();
		try{
			SECONDS.sleep(1);
		}finally{
			generator.cancel();
		}
		return generator.get();
	}

	PrimeGenerator使用一个简单的取消政策：客户端代码通过调用cancell方法来请求取消，PrimeGenerator每当一个质数找到就检测是否取消，当它检测到取     消请求时就退出。
