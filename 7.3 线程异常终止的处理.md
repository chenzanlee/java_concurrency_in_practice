## 7.3线程异常终止的处理
当一个单线程的控制台应用程序因为一个未被捕获的异常而终止时是很显然的————该程序停止运行，输出与正常的程序输出不同的堆栈。在并发应用程序中，一个线程的失败并不总是显而易见的。堆栈可能会打印到控制台，但是可能没人一直盯着控制台。此外，当一个线程失败时，应用可能看起来继续在工作，因而该线程的失败可能没人注意到。幸运的是，我们有检测和阻止线程从一个多线程应用中泄露的方法。
导致线程过早死亡的主要原因是运行时异常。因为这些异常表明一个程序错误或者其它不可修复的错误，它们一般不被捕获。相反，它们沿着调用栈一路向上传播，缺省的行为通常是在某个地方将异常堆栈打印到控制台，终止线程的执行。
线程异常死亡的后果可能是良性的，也可能是灾难性的，取决于线程在应用中扮演的角色。一个线程池失去一个线程可能会影响性能，但是一个在拥有50个线程的线程池下运行良好的应用很大可能也能在该线程池拥有49个线程的的情况下运行的不错。但是一个图形用户界面的应用如果失去了事件分发线程将非常引人注目————该应用将会停止处理事件，应用界面冻住。124页的OutOfTime向我们展示了线程泄露的严重后果：由Timer表示的服务将永远不会执行。
任何代码都有可能抛出一个运行时异常。无论何时你调用别的方法，你是在相信该方法将会正常返回，或者抛出一个它的方法签名中所声明的受检异常。你越是不熟悉正在被调用的代码，你越应该对它的行为保持怀疑。
像线程池中的工作线程或是在Swing框架中的事件分发线程这样的任务处理线程，它们的整个生命周期一直在调用未知代码，通过像Runnable这样的抽象封装接口，这些线程应该对它们调用的代码良好运行持怀疑态度。如果一个服务，如Swing事件线程，仅仅因为写得糟糕的事件处理器抛出一个运行时异常而挂掉就不太好。因此，这些服务
设施应该在一个捕获非受检异常的try-catch块中调用任务，或者在一个try-finally块中，确保当线程异常退出时，框架能够被告知到，从而能够采取一些正确的行动。这是仅有的几次你可能想要考虑捕获运行时异常的时机之一———当你调用通过像Runnable这样接口抽象的未知的，无法信任的代码时。
[Listing7.2.3]()举例说明了一种构建线程池中的工作线程的方式。如果一个任务抛出了一个不受检的异常，它允许线程死亡，但是在此之前必须向外部运行框架发出线程已经死亡的通知。该运行框架可能创建一个新的线程来替换该工作线程，或者因为该线程池正在关闭，又或者因为该线程池中已有足够的线程来满足当前的需求而选择不去替换。线程池执行器和Swing使用这一技术来确保一个表现糟糕的任务不会阻止后面的任务的执行。如果你正在写一个工作者线程类来执行提交过来的任务，或者调用一些无法信任的外部代码，诸如动态加载的插件，使用这些方法中的一种来避免线程因为碰巧调用一个写得很糟糕的任务或者插件挂掉。
### Listing 7.2.3 典型的线程池工作线程的结构
```
public void run(){
  Throwable thrown=null;
  try{
    while(!isInterrupted){
      runTask(getTaskFromWorkQueue());
    }catch(Throwable e){
      thrown=e;
    }finally{
      threadExited(this,thrown);
    }
  
  }

}
```
## 7.3.1未被捕获的异常的处理器
前面提供了一种主动的方式来应对非受检异常导致线程过早死亡的问题。线程类API也提供了UncaughtExceptionHandler机制，该机制能够让你检测到线程因为一个非受检异常死亡。这两种方式是互补的：同时使用两者，能够提供对线程泄露的更深层防御。当一个线程由于一个未被捕获的异常而退出时，java虚拟机将这一事件报告给一个应用程序范围内的UncaughtExceptionHandler（见 7.24）;如果该handler不存在，默认将会把线程调用栈打印到系统标准错误流。
```
### Listing 7.24 UncaughtExceptionHandler Interface
public interface UncaughtExceptionHandler{

}
```
该handler应该对一个未被捕获的异常做些什么取决于你的服务的质量要求。最通用的反应是像Listing 7.25所示那样将错误信息及发生异常时的该线程的方法调用栈输出到应用程序的日志中。Handlers也可以采取一些更直接的动作，诸如试着去重启线程，关闭该应用，paging an operator,或者别的一些正确或者诊断性的动作。

### Listing 7.25 记录异常的UncaughtExceptionHandler
```
public class UEHLogger implements Thread.UncaughtExceptionHandler{
  public void uncaughtException(Thread t,Throwable e){
    Logger logger=Logger.getAnonymousLogger();
    logger.log(Level.SEVERE,"Thread terminated with exception :"+t,getName(),e);
  }
}
```
在一个长时间运行的应用中，总是为所有的线程使用至少记录下该异常的未被捕获的异常的处理者。

可以通过提供一个ThreadFactory给线程池构造器，来为线程池中的线程设置一个UncaughtExceptionHandler。（和所有的线程操作一样，只有线程的拥有者应该改变它的UncaughtExceptionHandler。)标准的线程池允许一个未被捕获的任务异常终结线程池中的线程，但是使用一个try-finally块来通知线程池这一事件发生，以便该线程能够被替代。如果没用未被捕获异常处理器或者采取别的失败通知机制，任务可能会悄无声息地失败，这将令人感到困惑。如果你想要在一个任务由于异常而导致失败时收到该任务失败的通知，以便你能够采取一些特定于任务的恢复行动，你可以使用捕获异常的Runnable或者Callable接口包装任务或者覆写ThreadPoolExecutor类中的afterExecute()钩子方法。

有点令人困惑的是，任务抛出的异常交由UncaughtExceptionHandler处理，只对那些通过execute方法提交的任务有效。对那些通过submit方法提交的任务,任何抛出的异常，无论是受检的异常还是不受检的异常，将被视作任务的返回状态的一部分。如果一个通过submit方法提交的任务由于一个异常终结，该异常将被包裹进一个ExecutionException，通过future的get方法重新抛出。

